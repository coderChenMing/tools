## 关于String类

String 对象是使用最频繁的对象之一，对它的优化一直没有停止过，包括编译阶段。字符串，我们经常用“+”连接，针对这种情况，编译器是可以进行优化的，“+”连接形式创建字符串分两种情况：

1、使用常量的字符串连接创建是也是常量，编译期就能确定了，直接入字符串常量池，比如 String str1  = "ab" + "cd"， "ab" 和 "cd" 都是常量，编译器优化后的代码为：String str1  = "abcd"。（注意：final 修饰的变量如果是常量，可以认为等同于字面量）

2、使用“+”连接字符串中含有变量时，这种情况在运行期才能确定。


intern 方法是一个 native 方法，intern 方法会从字符串常量池中查询当前字符串是否存在，如果存在，就直接返回当前字符串；如果不存在就会将当前字符串放入常量池中，之后再返回。


从源码中我们可以看到 String 类是被定义为 final 的，这就意味着 String 类是不可以被继承的（这里又产生一个问题，为什么 String 要被设计成 final 呢？）。

可以看到，value[] 是存储 String 的内容的，即当使用 String str = "abc" 的时候，本质上 "abc" 是存储在一个 char 类型的数组中的。

而 hash 是 String 实例化的 hashcode 的一个缓存。因为 String 经常被用于比较，比如在 HashMap 中。如果每次进行比较都重新计算 hashcode的值的话，那无疑是比较麻烦的，而保存一个 hashcode 的缓存无疑能优化这样的操作。

我们知道了 String 内部其实是通过 char[] 实现的，我们可以轻易发现 equals()，isEmpty()，charAt() 这些方法其实就是在内部调用数组的方法。



JVM 为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM 会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于 String 字符串的不可变性，常量池中一定不存在两个相同的字符串。




## String 类不可变性的好处

不知道你注意前文中的一段文字没，“一般来说，字符串的分配和其他对象分配一样，是需要消耗时间和空间的，而且字符串使用的非常多。JVM 为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM 会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于 String 字符串的不可变性，常量池中一定不存在两个相同的字符串。”

只有当字符串是不可变的，字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么 String intern 将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。

其次，如果字符串是可变的，那么会引起很严重的安全问题，譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的。否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。而正是因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。

另外，基于效率考虑，因为字符串是不可变的，所以我们可以缓存 String 的 hashcode，不需要重新计算，这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。


## String 真的不可变吗？

需要补充一个知识点：当使用 final 修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。


前文源码可知 String 的成员变量是private final 的，也就是初始化之后不可改变。那么在这几个成员中，value 比较特殊，它是一个数组变量引用，而不是真正的对象。value是 final 修饰的，也就是说final 不能再指向其他数组对象，那么我能改变 value 指向的数组吗？

一般来说在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个 value 引用，更不能通过这个引用去修改数组。那么用什么方式可以访问私有成员呢？没错，用反射，可以通过反射出获取 String对象中的 value 属性，进而改变通过获得的 value 引用改变数组的结构。



## 如何设计一个不可变类

讲了那么多，String 是如何实现不可变的呢，或者说如何实现一个final 类？在有些场景下，我们需要特殊的对象作为 map 的 key，实现这个 key 需要注意什么？

不可变类，可以理解为，只允许读，不允许修改的类，类的对象一旦创建，就不能再进行修改了。

需要遵循以下几个原则：


Immutable 对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。

Immutable类的所有的属性都应该是 final 的。

对象必须被正确的创建，比如：对象引用在对象创建过程中不能泄露( leak )。

对象应该是 final 的，以此来限制子类继承父类，以避免子类改变了父类的 immutable 特性。

如果类中包含 mutable 类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身, Effective Java 第39条中提到：必要时进行保护性拷贝，总结一句就是：成员变量不要被外部引用直接赋值，而是拷贝之后的赋值。



具体来说，要将一个 Java 类构造成不可变的类，必须执行以下操作：

1、 将类声明为 final，这样就不会重写它。如果可以重写类的话，则可以重写它的方法的行为，因此最安全的选择就是不允许将类子类化。

2、 保证所有成员变量必须私有，并且加上final修饰。通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。

3、 不提供改变成员变量的方法，包括setter，避免通过其他接口改变成员变量的值，破坏不可变特性。

4、 通过构造器初始化所有成员，进行深拷贝(deep copy)，为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。

5、 在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。