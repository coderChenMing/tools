# hashmap实现一个过期缓存

## 缓存类型

* 本地缓存

    caffeine 一个优秀的进程缓存框架（据说是本地缓存性能最高）

    guava google的Java类库

* 中间件缓存

    redis (优秀的分布式缓存中间件)

    memcached (缓存中间件，相对redis功能来说较少)

项目在实际落地中可能是单机版本的，也可能是分布式版本的，所以通用缓存接口的逻辑默认支持两种，即本地缓存和分布式缓存。
对于本地缓存的使用，虽然上述的本地缓存框架比较成熟，但是根据项目的特性，还是考虑自己实现一个适用项目的简单的本地缓存存储容器。主要考虑到以下几个方面：
* caffeine 和guava cache 都支持可过期的缓存key,但是对于每个key设置过期时间的场景下，就显得有些乏力，需要每次在存储缓存时，创建对应的cache对象，随着key的增多，资源消耗会直线成长，redis自带key单独设置过期时间，所以不用考虑。
* 对于外部的依赖的类库，会增加一部分的学习成本，且会与第三方类库进行强绑定。
* 抱着学习的态度，尝试利用已知原理动手实现解决现有问题


## **设计思考**
* 使用的缓存存储器需要支持Key-Value存储，HashMap是个比较好的选择，HashMap的代码是JDK自带的，如何给HashMap添加新特性？
* 需要让单个Key过期，且每个Key的过期时间都是可以自定义的，怎么让HashMap中的Key自动过期是一个问题？
* HashMap多线程读写情况下会出现数据不一致甚至可能报错的情况，怎么避免？

## **设计实现**
* 使用HashMap做Key-Value的存储容器，可以使用继承的方式来为HashMap添加支持单个Key过期的特性
* 缓存的过期时间由另外一个HashMap来控制，即一个HashMap存储Key-Value，另一个存储Key-ExpireTime.
* 单独的Key的过期时间的控制在get(K key)的时候判断，即如果key 超过了过期时间就返回null,没有过期则返回其Value
* 线程安全问题要通HashMap一致，由调用逻辑控制，容器本身不考虑线程安全问题
